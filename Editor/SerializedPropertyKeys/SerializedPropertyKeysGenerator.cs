using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEngine;
using YanickSenn.CodeGen.Attributes;

namespace YanickSenn.CodeGen.Editor.SerializedPropertyKeys
{
    [Generator]
    public class SerializedPropertyKeysGenerator : IGenerator
    {
        [DidReloadScripts]
        public static void OnScriptsReloaded()
        {
            // We can rely on CodeGenPostprocessor, but VariableGenerator has this too.
            // However, CodeGenPostprocessor calls Generate() on all generators.
            // If I add this, it might double generate if CodeGenPostprocessor is also working.
            // VariableGenerator has it, maybe because CodeGenPostprocessor relies on AssetPostprocessor which triggers on import,
            // but OnScriptsReloaded triggers after compilation.
            // I'll keep it to be safe/consistent, or maybe CodeGenPostprocessor is enough?
            // Let's stick to the pattern in VariableGenerator.
            // Wait, VariableGenerator.OnScriptsReloaded calls TriggerGeneration -> new VariableGenerator().Generate().
            // CodeGenPostprocessor also calls Generate().
            // I will skip DidReloadScripts for now to avoid potential double work, 
            // relying on CodeGenPostprocessor which seems to be the main entry point for auto-generation.
            // Actually, VariableGenerator's TriggerGeneration is for the MenuItem.
            // Let's add the MenuItem.
        }

        [MenuItem("Tools/Code Generation/Force Generate Serialized Property Keys")]
        public static void TriggerGeneration()
        {
            new SerializedPropertyKeysGenerator().Generate();
        }

        public void Generate()
        {
            var targetTypes = TypeCache.GetTypesWithAttribute<GenerateSerializedPropertyKeysAttribute>();
            var outputDir = "Assets/Generated/SerializedPropertyKeys";

            if (!Directory.Exists(outputDir))
            {
                Directory.CreateDirectory(outputDir);
            }

            foreach (var type in targetTypes) {
                GenerateKeysForType(type, outputDir);
            }

            AssetDatabase.Refresh();
        }

        public void Clear()
        {
            var outputDir = "Assets/Generated/SerializedPropertyKeys";
            if (Directory.Exists(outputDir))
            {
                Directory.Delete(outputDir, true);
                File.Delete(outputDir + ".meta");
            }
            AssetDatabase.Refresh();
        }

        public bool ShouldRetriggerGenerationForAsset(string assetPath)
        {
            // Simple check: if a script changes, we might need to regenerate keys if fields changed.
            // Ideally we check if the script defines a type with the attribute.
            // For now, let's return true for .cs files or similar?
            // VariableGenerator returned false in the interface default?
            // IGenerator default is false.
            // CodeGenPostprocessor calls Generate() if ShouldRetrigger returns true.
            // If I return false, it won't auto-trigger on simple asset changes unless OnPostprocessAllAssets logic in CodeGenPostprocessor covers it?
            // CodeGenPostprocessor iterates generators and checks ShouldRetriggerGenerationForAsset.
            // If I want auto-generation when I edit the script, I should implement this. 
            
            return assetPath.EndsWith(".cs");
        }

        private void GenerateKeysForType(Type type, string outputDir)
        {
            var fields = GetSerializableFields(type).OrderBy(f => f.Name).ToList();
            if (fields.Count == 0) return;

            var className = $"{type.Name}Keys";
            var filePath = Path.Combine(outputDir, $"{className}.cs");
            
            var sb = new StringBuilder();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine($"//     This code was generated by {GetType().FullName}.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine("using YanickSenn.CodeGen.Attributes;");
            sb.AppendLine();
            sb.AppendLine("namespace YanickSenn.Generated.SerializedPropertyKeys");
            sb.AppendLine("{");
            sb.AppendLine("    [Generated]");
            sb.AppendLine($"    public static class {className}");
            sb.AppendLine("    {");

            foreach (var field in fields)
            {
                // Verify the field name is a valid identifier for a constant? 
                // Usually yes, but might need sanitization if it contains special chars (unlikely for fields).
                // Constant name: FieldName. 
                // Value: "fieldName".
                
                var constName = field.Name;
                var constValue = field.Name;
                
                // If it's a backing field, it might look like <Prop>k__BackingField. 
                // SerializedProperty uses the field name.
                
                sb.AppendLine($"        public const string {constName} = \"{constValue}\";");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            var content = sb.ToString();
            if (!File.Exists(filePath) || File.ReadAllText(filePath) != content)
            {
                File.WriteAllText(filePath, content);
                Debug.Log($"Generated serialized property keys: {filePath}");
            }
        }

        private IEnumerable<FieldInfo> GetSerializableFields(Type type)
        {
            var allFields = new List<FieldInfo>();
            var currentType = type;
            
            // Traverse hierarchy up to Unity Object or system Object
            while (currentType != null && currentType != typeof(UnityEngine.Object) && currentType != typeof(object))
            {
                var fields = currentType.GetFields(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly);
                foreach (var field in fields)
                {
                    if (IsSerializable(field))
                    {
                        allFields.Add(field);
                    }
                }
                currentType = currentType.BaseType;
            }

            // Filter out duplicates (shadowing) - keep the most derived one?
            // If Child shadows Parent field, GetFields loops child first (if we started there).
            // But we are iterating up. 
            // Let's use a dictionary or distinct by name.
            // If Child shadows Parent's "myField", they are different fields.
            // But if they have the same name, we can't generate two constants with the same name.
            // We should probably keep the derived one.
            
            var distinctFields = new Dictionary<string, FieldInfo>();
            // Since we went from Derived -> Base (no wait, we can't easily go Derived->Base in a loop unless we start at type and go .BaseType).
            // Yes, the loop is `currentType = type; ... currentType = currentType.BaseType`.
            // So we encounter Derived fields first.
            
            foreach (var field in allFields)
            {
                if (!distinctFields.ContainsKey(field.Name))
                {
                    distinctFields.Add(field.Name, field);
                }
            }
            
            Debug.Log(distinctFields.Count);
            return distinctFields.Values;
        }

        private bool IsSerializable(FieldInfo field)
        {
            // Static fields are not serialized
            if (field.IsStatic) return false;

            // Const fields are static literals, not serialized
            if (field.IsLiteral) return false;

            // Readonly? Unity doesn't serialize readonly fields.
            if (field.IsInitOnly) return false;

            if (field.IsPublic)
            {
                return !Attribute.IsDefined(field, typeof(NonSerializedAttribute));
            }

            return Attribute.IsDefined(field, typeof(SerializeField));
        }
    }
}
