using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using YanickSenn.Utils.Editor;
using YanickSenn.Utils.Events;

namespace YanickSenn.CodeGen.Editor {

    [Generator]
    public class EventRegistryGenerator : IGenerator {

        [MenuItem("Tools/Code Generation/Force Generate Event Registry")]
        public static void TriggerGeneration() {
            new EventRegistryGenerator().Generate();
        }

        public void Generate() {
            var outputDir = "Assets/Generated/EventRegistry";
            if (!Directory.Exists(outputDir)) {
                Directory.CreateDirectory(outputDir);
            }

            var eventAssets = FindAllEventAssets();
            GenerateRegistry(eventAssets, outputDir);

            AssetDatabase.Refresh();
        }

        public void Clear() {
            var filePath = "Assets/Generated/EventRegistry/EventRegistry.cs";
            if (File.Exists(filePath)) {
                File.Delete(filePath);
                File.Delete(filePath + ".meta");
            }
            AssetDatabase.Refresh();
        }

        public bool ShouldRegenerateForAsset(string assetPath) {
            if (string.IsNullOrEmpty(assetPath)) {
                return false;
            }

            // Regenerate if an event asset is modified/added/deleted
            var type = AssetDatabase.GetMainAssetTypeAtPath(assetPath);
            return IsEventType(type);
        }

        private static bool IsEventType(Type type) {
            if (type == null) return false;
            if (typeof(GlobalEvent).IsAssignableFrom(type)) return true;

            var currentType = type;
            while (currentType != null && currentType != typeof(object)) {
                if (currentType.IsGenericType && currentType.GetGenericTypeDefinition() == typeof(Event<>)) {
                    return true;
                }
                currentType = currentType.BaseType;
            }
            return false;
        }

        private List<ScriptableObject> FindAllEventAssets() {
            var eventTypes = new List<Type>();
            eventTypes.Add(typeof(GlobalEvent));
            eventTypes.AddRange(TypeCache.GetTypesDerivedFrom(typeof(Event<>))
                .Where(t => !t.IsAbstract && !t.IsGenericType));

            var allAssets = new Dictionary<string, ScriptableObject>();

            foreach (var type in eventTypes) {
                var assets = InjectionUtils.FindAssetsByType(type);
                foreach (var asset in assets) {
                    var path = AssetDatabase.GetAssetPath(asset);
                    if (!allAssets.ContainsKey(path)) {
                        allAssets.Add(path, asset);
                    }
                }
            }

            return allAssets.Values.OrderBy(a => a.name).ToList();
        }

        private void GenerateRegistry(List<ScriptableObject> assets, string outputDir) {
            var className = "EventRegistry";
            var filePath = Path.Combine(outputDir, $"{className}.cs");

            var sb = new StringBuilder();
            sb.AppendLine("using VContainer;");
            sb.AppendLine("using UnityEngine;");
            sb.AppendLine("using YanickSenn.CodeGen.Attributes;");
            sb.AppendLine("using YanickSenn.Utils.Events;");
            sb.AppendLine("using YanickSenn.Utils.VContainer;");
            sb.AppendLine();
            sb.AppendLine("// <auto-generated>");
            sb.AppendLine("//     This code was generated by YanickSenn.CodeGen.Editor.Events.EventRegistryGenerator.");
            sb.AppendLine("//     Changes to this file may cause incorrect behavior and will be lost if");
            sb.AppendLine("//     the code is regenerated.");
            sb.AppendLine("// </auto-generated>");
            sb.AppendLine();
            sb.AppendLine($"[Generated]");
            var menuName = ObjectNames.NicifyVariableName(className);
            sb.AppendLine($"[CreateAssetMenu(fileName = \"{className}\", menuName = \"Registry/{menuName}\")]");
            sb.AppendLine($"public class {className} : ScriptableObjectInstaller {{");
            sb.AppendLine();

            // Keys Enum
            sb.AppendLine("    public enum Keys {");
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                sb.AppendLine($"        {fieldName},");
            }
            sb.AppendLine("    }");
            sb.AppendLine();

            // Fields
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                var typeName = asset.GetType().FullName.Replace('+', '.');
                sb.AppendLine($"    public {typeName} {fieldName};");
            }

            sb.AppendLine();
            sb.AppendLine("    public override void Install(IContainerBuilder builder) {");

            // Registration
            foreach (var asset in assets) {
                var fieldName = InjectionUtils.SanitizeName(asset.name);
                sb.AppendLine($"        if ({fieldName} != null) {{");
                sb.AppendLine($"            builder.RegisterInstance({fieldName}).Keyed(Keys.{fieldName});");
                sb.AppendLine($"        }}");
            }

            sb.AppendLine("    }");
            sb.AppendLine("}");

            var content = sb.ToString();
            if (!File.Exists(filePath) || File.ReadAllText(filePath) != content) {
                File.WriteAllText(filePath, content);
                Debug.Log($"Generated registry: {filePath}");
            }
        }
    }
}
